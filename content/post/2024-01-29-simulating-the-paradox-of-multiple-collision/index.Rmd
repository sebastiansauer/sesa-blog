---
title: Simulating multiple event collision
author: Sebastian Sauer
date: '2024-01-29'
slug: simulating-multiple-event-collision
categories:
  - rstats
tags:
  - simulation
output:
  blogdown::html_page:
    toc: yes
    number_sections: yes
---



```{r knitr-setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE,
  out.width = "100%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  size = "tiny"
)
```


# Motivation

Have you ever tried to find a time slot for a meeting using a tool such as "[Doodle](https://doodle.com/en/)"?



If not, consider yourself lucky.
Otherwise you will be well aware of the chagrin of finding a time slot that suits all of your colleagues.

Let's call a time slot where all of your colleagues invited for the meeting have a free time slot a *matching time slot*, or a *match* for short.


Here's a sample image for a "doodle" in order to find a a match.

![](doodle.png)

Some persons find that the best way to find a matchting time slot is to offer a great number of time slots to your colleagues. 
Personally I find this appraoch difficult as I would have to keep track of and block a lot of time slots in my calendar. In addition, I feel it would be difficult to find a matching time slot as most colleagues will not take the hazzle and report many free time slots.
Call me pessimistic, but I suspect that most colleagues will choose about 3 time slots, but not more, because it would be too difficult for them to keep their calendars in sync. (A sentiment I share.)

Now, I wondered that's the probability of finding at least one matching time slot when addressing *n* colleagues, providing each of them with *o* options, assuming each colleague will pick *p* options completely random.

In more stochastic parlance, this problem is a somewhat involved example of the collision problem.

Here's a simulation study for that.

# Setup

```{r load-libs, message = FALSE, warning = FALSE}
library(tidyverse)  # data wrangling
library(tictoc)  # measure time
```




# Constants/Parameters


```{r}
n_colleagues <- 3  # number of colleagues invited to your meeting
p <- 3  # number of appointment options _p_icked per colleague
o <- 30 # number of possible _o_ptions to choose from
r <- 1e3  # number of simulated _r_epetions/samples
```


# Model

A number of `n_colleague` colleagues pick *p* options from a list of *o* possible options.
We are interested in the probability that all colleagues pick (at least) one time the same slot.
We consider the the number picked options, *p*, fix.


# Some Assumptions

1. Picking slots (within a colleague) is independent, eg., picking slot 1 is indepent from picking slot 2. In other words, knowing that you have picked slot 1 does not tell my anythin new about the probability that you will pick slot 2.

2. The colleagues pick slots independently from each other.


# Example

Three colleagues - A,B,C - pick 3 slots from 10 options. 

For example, colleague A picks options 1, 2, and 3.


| Colleague 	| Pick1 	| Pick2 	| Pick3 	|
|-----------	|-------	|-------	|-------	|
| A         	| 1     	| 2     	| 3     	|
| B         	| 1     	| 7     	| 9     	|
| C         	| 1     	| 7     	| 10    	|




We have one match: All chose the option 1. (And to choose the option, but that's not enough for a match, as not all persons chose this number.)

# Analytical approach


## Limiting to picking 1 option

Finding an analytical solution for the probability of $n$ person picking 1 number from $o$ options is quite straight forward.
For example, let's assume for the moment $n=3, o=10$. Then we have

1. The first person can choose any number, i.e., $Pr_1=1$.
2. The second person must choose the same number as the first one, so 1 out of 10, ie., $Pr_2=1/10$.
3. The third peson must again choose the same number, so $Pr_3=1/10$.

In total, $Pr = Pr_1 \cdot Pr_2 \cdot Pr_3$, as we assume independence between persons.

More generally, $Pr = \frac{1}{o}^{n-1}$.

## Generalizing to picking $p$ options

Let's consider picking $p=3$ options.

One might think that the solution is

$Pr =  \frac{1}{o}^{n-1} +  \frac{1}{o-1}^{n-1} + \frac{1}{o-2}^{n-1}$

but this appears not to be quite right, at least quite different numbers are found using the Monte Carlo approach below.




## Monte Carlo as an alternative

Anyhow, a simple alternative to an analytical solution is to use simulation, ie., a Monte Carlo approach.


# Funs


## Count common slots


This functions checks whether there's (at leat) one match.

A match is defined as a sample where some picked options appears at least as often as colleagues were involved.
For example, if you addressed 3 colleagues, and all there sayed that option number 1 is fine, than you have a match.

```{r fun-count-common-slots}
count_common_slots <- function(n_colleagues, o, p){
  
  slots_chosen_l <- list()

  # make sure that only so many options can be picked as are available:
  if (p > o) p <- o
  
  for (i in 1:n_colleagues){  # for each collegue addressed:
    slots_chosen_l[[i]] <- sample(1:o, size = p)  # pick p options from o possible options
  }
  slots_chosen <- unlist(slots_chosen_l)
  
  # a R table allows to easily find matches:
  slots_chosen_tbl <- slots_chosen |> table() 
  
  # a match is where a picked options has a frequency of (at least) 3,
  # if 3 colleagues were addressed, etc.:
  slots_chosen_collision <- slots_chosen_tbl[slots_chosen_tbl >= n_colleagues]
  
  slots_chosen_df <- data.frame(slots_chosen_collision)
  
  # take care of border cases, only different options chosen:
  if (nrow(slots_chosen_df) == 0) slots_chosen_df <- 
    data.frame(slots_chosen = factor(NA), Freq = NA_integer_)
  
  # if there's 1 match, tabl() returns a single number only, 
  # so we have to make sure it looks like a real table:
  if (ncol(slots_chosen_df) == 1) slots_chosen_df <- 
    data.frame(slots_chosen = factor(row.names(slots_chosen_df)), 
               Freq = slots_chosen_df$slots_chosen_collision)
  
  # add a column indicatin whether we have a match or not:
  slots_chosen_df$is_match <- FALSE
  slots_chosen_df$is_match[!is.na(slots_chosen_df$slots_chosen)] <- TRUE
  
  # add the relevant parameters as attributes to the dataframe:
  attr(slots_chosen_df, "n_colleagues") <- n_colleagues
  attr(slots_chosen_df, "o") <- o
  attr(slots_chosen_df, "p") <- p
   
  return(slots_chosen_df)
}
```


Test it:

```{r}
#undebug(count_common_slots)
slots_chosen_collision <- count_common_slots(n_colleagues = 4, 
                                             o = 5, 
                                             p = 3)
slots_chosen_collision
```


```{r}
attributes(slots_chosen_collision)
```


## Estimate common slots


This functions draws many simulated samples.



```{r fun-estimate-common-slots}
estimate_common_slots <- function(slots_chosen_collision, n_colleagues, o, p, r = 1e3){
  
  smples <- 
    slots_chosen_collision |> 
    # add id for further reference:
    mutate(id = 1)
  
  # repeat r times, giving us many simulated samples:
  for (i in 2:r) {
    tmp <- count_common_slots(n_colleagues = n_colleagues, o = o, p = p)
    tmp$id <- i
    
    smples <-
      smples |> 
      bind_rows(tmp)
  }
  
  attr(smples, "n_simulated_samples") <- r
  
  return(smples)
}
```






Check:

```{r}
smples <- estimate_common_slots(slots_chosen_collision = slots_chosen_collision,
                                n_colleagues = n_colleagues,
                                o = o,
                                p = p)

glimpse(smples)
```

```{r}
attr(smples, "n_simulated_samples")
attr(smples, c("o"))
attr(smples, "p")
```



## Samples summarized

This function counts the matches.

```{r fun-summ-samples}
summarize_samples <- function(smples){
  
   smples_tbl <-
   smples |> 
   #mutate(Freq = replace_na(Freq, 0)) |> 
   group_by(Freq) |> 
   summarise(n_matches = n()) |> 
   mutate(prop_matches = n_matches / sum(n_matches)) 
   #mutate(Freq = replace_na(Freq, 0))
   
   return(smples_tbl)
  
}
```

Check:

```{r}
smples_tbl <- summarize_samples(smples)
smples_tbl
```


## Proportion of matches


This helper functions extracts the probability of a match - given the parameters n,p,o,r - from the data frame returned by `summarize_samples(smples)`.



```{r fun-prop-match}
prop_match <- function(smples_tbl, n_colleagues){
  
  smples_tbl_we_found_slot <- 
  smples_tbl |> 
    mutate(Freq = replace_na(Freq, 0)) |> 
     group_by(we_found_slot = factor(Freq >= n_colleagues, levels = c(FALSE, TRUE)), .drop = FALSE) |> 
  summarise(n_matches = sum(n_matches)) |> 
    mutate(prop_matches = n_matches/sum(n_matches)) 
  
  out <- smples_tbl_we_found_slot$prop_matches[smples_tbl_we_found_slot$we_found_slot == TRUE]
  
  return(out)
}
```


```{r}
prop_match(smples_tbl, n_colleagues = n_colleagues)
prop_match(smples_tbl, n_colleagues = n_colleagues + 1)
prop_match(smples_tbl, n_colleagues = n_colleagues - 1)
```




## Plot results

```{r}
plot_matches <- function(smples_tbl, n_colleagues, p, o){

  smples_tbl |> 
    mutate(Freq = replace_na(Freq, -99)) |> 
    group_by(we_found_slot = 
               factor(Freq >= n_colleagues, levels = c(FALSE, TRUE)), 
             .drop = FALSE) |> 
    summarise(n_matches = sum(n_matches),
              prop_matches = sum(prop_matches)) |> 
    ggplot() +
  aes(x = we_found_slot, y = prop_matches) +
    geom_col() +
    labs(title = "Proportion of collisions",
         subtitle = paste0(n_colleagues, " colleagues, ", p, " picked time slots, ", o, " options to chose from, ", r, " simulated samples"),
         caption = "The vertical line indicates the event that enough colleagues chose the same time slot.") +
    geom_label(aes(label = round(prop_matches, 2), x = we_found_slot)) 
}
```


```{r}
plot_matches(smples_tbl, n_colleagues, p, o)
```





## All in once function

Here's the do-it-all-in-once function:

```{r fun-matching-prob}
matching_prob <- function(n_colleagues,
                          o,
                          p,
                          r = 1e3,
                          return_prob = TRUE
                          ) {
  first_common_slot <- count_common_slots(n_colleagues, o = o, p = p)
  all_common_slots <- estimate_common_slots(first_common_slot,
                                            n_colleagues = n_colleagues,
                                            o = o,
                                            p = p)
  out <- summarize_samples(all_common_slots)
  
  if (return_prob) {
    out <- prop_match(out, n_colleagues = n_colleagues)
    stopifnot(class(out) == "numeric")
  }
  
  return(out)
}
```


Check it:

```{r}
#undebug(matching_prob)
matching_prob(n_colleagues = 5,
              o = 10,
              p = 3)
```


# Some examples

3 colleagues pick 1 option from 10 options:

```{r}
matching_prob(n_colleagues = 3,
              o = 8,
              p = 1)
```



3 colleagues pick 2 options from 10 options:


```{r}
matching_prob(n_colleagues = 3,
              o = 10,
              p = 2)
```

# Sampling distribution

Get the sampling distribution:


```{r smpl_distrib1}
tic()
smpl_distrib <- mosaic::do(50) * matching_prob(5, 10, 3)
toc()
```


```{r}
mean(smpl_distrib$matching_prob)
sd(smpl_distrib$matching_prob)
```


```{r}
ggplot(smpl_distrib) +
  aes(x = matching_prob) +
  geom_density()
```




As can be seen, the probability of finding a matching time slot is quite small, given the parameter values above.
Not impossible, but too low to rely on this approach in my opinion.


# o=10; Make a matching more probable

Let's provide less options to chose from in order to find a time slot for the meeting to your colleagues:



```{r}
n_colleagues <- 3
o <- 7

#debug(matching_prob)
smples_tbl2 <- matching_prob(n_colleagues = n_colleagues,
                              o = o,
                              p = p,
                              return_prob = FALSE)

smples_tbl2
```


Looks much better; we have some realistic chances of finding a match.


```{r fig.width=9}
plot_matches(smples_tbl2, n_colleagues, p = p, o = o)
```


Now we can see that a matching has become more probable, although still not highly likely.






# o=5; Make a matching highly probable

Let's provide only a few options too chose from in order to find a time slot for the meeting to your colleagues:





```{r plot-smpls3, fig.width=9}
o <- 5  # number of time slot options too chose from

smples_tbl3 <- matching_prob(n_colleagues = n_colleagues,
              o = o,
              p = p,
              return_prob = FALSE)

plot_matches(smples_tbl3,  n_colleagues, p = p, o = o)
```



That really looks good; that's a realistic chance to find a match.

# Grid of different parameter values


Let's try different parameter values and compute the probability of a match.

Here's the grid using a cartesian expansion:

```{r}
d <- expand_grid(n_colleagues = 2:5,
                 o = c(5, 10, 15, 20, 25, 30),
                 p = c(3, 5, 7, 10))
```




# Populate grid


```{r populate-grid}
tic()
d_grid <-
  d |> 
  mutate(match_prob = 
           pmap_dbl(
             .l = list(n_colleagues, o, p), 
             .f = matching_prob,
             .progress = TRUE))
toc()
```

Quite slow.

```{r}
glimpse(d_grid)
```



# Visualize grid 1


```{r vis-grid, fig.asp = 1.5, out.width="100%"}
d_grid |> 
  rename(n = n_colleagues) |> 
  ggplot(aes(x = o, y = match_prob)) +
  geom_line() +
  geom_point() +
  facet_grid(n ~ p,
             labeller = labeller(n = label_both, p = label_both)) +
  labs(title = "Proportiong of a match when Doodling for an joint meeting",
       caption = "p: Number of options picked per colleague;\n
       n: number of colleagues approached"
       )
```

# Visualize grid 2

Let's try a different visualization.


Here's a little love for the labels of the line:

```{r}
d_grid_labels <- 
d_grid |> 
  mutate(n_colleagues = factor(n_colleagues)) |> 
  group_by(p, n_colleagues) |> 
  summarise(X = max(o), 
            Y = last(match_prob))

glimpse(d_grid)
```


```{r vis-grid2, fig.asp = 1.5}
# d_grid_long <-
#   d_grid |> 
#   pivot_longer(cols = c(n_colleagues, p))

d_grid |> 
  rename(n = n_colleagues) |> 
  mutate(n = factor(n)) |> 
  ggplot(aes(x = o, y = match_prob)) +
  geom_line(aes(color = n, group = n)) +
  geom_point(aes(color = n, group = n)) +
  facet_wrap(~  p , labeller = labeller(p = label_both), ncol = 2) +
  labs(title = "Proportiong of a match when 'doodling' for an joint meeting",
       caption = "p: Number of options picked per colleague;\n
       n: number of colleagues approached;\n
       o: number of available time slot options to choose from",
       y = "Probality of a match",
       color = "number of\ncolleagues",
       text = "") +
  theme_light() +
  theme(legend.position = "none") +
  geom_label(data = d_grid_labels,
             aes(label = paste0("n: ", n_colleagues), 
                 x = X, y = Y, color = factor(n_colleagues))) +
  expand_limits(x = max(d_grid$o) + 1)
```


# Caveats

This analysis builds on some assumptions. One is that the the colleagues choose their slots randomly. 
However, assumption may fail.
For example, if 3 have 5 options and ask to choose 3, people may feel pushed too hard and do crazy things.



# Conclusion

There are a number of things to be learnt from this simulation:

1. The higher the number of _o_ptions to pick from, the less likely is it to come to a match.
2. The highher the number of _p_icked appointment options, the more likely it is to come to a match.
3. The more colleagues are in the game, the less likely it is to come to a match.

All these insights are straight forward. However, we can also make some quantitative conclusions:

- More than 20 options to choose from is crazy no matter what.
- If each colleagues picks 3 options only (what I would do), than you need to present less than 10 options. 
- If you can present 5 options only, you will be on the safe side and will likely come to a match.



# Reproducibility

```{r reproducibility, echo = FALSE}
## Reproducibility info
options(width = 120)
devtools::session_info()

```


