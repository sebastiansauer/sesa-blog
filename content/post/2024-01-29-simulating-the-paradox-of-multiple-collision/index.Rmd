---
title: Simulating multiple event collision
author: Sebastian Sauer
date: '2024-01-29'
slug: simulating-multiple-event-collision
categories:
  - rstats
tags:
  - simulation
output:
  blogdown::html_page:
    toc: yes
    number_sections: yes
---



```{r knitr-setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE,
  out.width = "100%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold",
  size = "tiny"
)
```


# Motivation

Have you ever tried to find a time slot for a meeting using a tool such as "Doodle"?

If not, consider yourself lucky.
Otherwise you will be well aware of the chagrin of finding a time slot that suits all of your colleagues.

Let's call a time slot where all of your colleagues invited for the meeting have a free time slot a *matching time slot*.

Some persons find that the best way to find a matchting time slot is to offer a great number of time slots to your colleagues. 
Personally I find this appraoch difficult as I would have to keep track of and block a lot of time slots in my calendar. In addition, I feel it would be difficult to find a matching time slot as most colleagues will not take the hazzle and report many free time slots.
Call me pessimistic, but I suspect that most colleagues will choose about 3 time slots, but not more, because it would be too difficult for them to keep their calendars in sync. (A sentiment I share.)

Now, I wondered that's the probability of finding at least one matching time slot when addressing *n* colleagues, providing each of them with *o* options, assuming each colleague will pick *p* options completely random.

In more stochastic parlance, this problem is a somewhat involved example of the collision problem.

Here's a simulation study for that.

# Setup

```{r load-libs, message = FALSE, warning = FALSE}
library(tidyverse)  # data wrangling
```


Initialize variables:

```{r}
slots_chosen <- list()
```



# Constants/Parameters


```{r}
n_colleagues <- 3  # number of colleagues invited to your meeting
p <- 3  # number of appointment options _p_icked per colleague
o <- 30 # number of possible _o_ptions to choose from
r <- 1e3  # number of simulated _r_epetions/samples
```






# Funs


## Count common solots



```{r fun-count-common-slots}
count_common_slots <- function(n_colleagues, o, p){
  
  # make sure that only so many options can be picked as are available:
  if (p > o) p <- o
  
  for (i in 1:n_colleagues){
    slots_chosen[[i]] <- sample(1:o, size = p)
  }
  slots_chosen_vec <- unlist(slots_chosen)
  slots_chosen_tbl <- slots_chosen_vec |> table() 
  
  slots_chosen_collision <- slots_chosen_tbl[slots_chosen_tbl >= n_colleagues]
  
  slots_chosen_df <- data.frame(slots_chosen_collision)
  
  if (nrow(slots_chosen_df) == 0) slots_chosen_df <- data.frame(slots_chosen_vec = factor(NA),
                                                                Freq = NA_integer_)
  if (ncol(slots_chosen_df) == 1) slots_chosen_df <- data.frame(slots_chosen_vec = factor(row.names(slots_chosen_df)),
                                                                Freq = slots_chosen_df$slots_chosen_collision)
  
  return(slots_chosen_df)
}
```


Test it:

```{r}
undebug(count_common_slots)
slots_chosen_collision <- count_common_slots(n_colleagues = 4, 
                                             o = 5, 
                                             p = 3)
slots_chosen_collision
```


## Estimate common slots



```{r fun-estimate-common-slots}
estimate_common_slots <- function(slots_chosen_collision, n_colleagues, o, p, r = 1e3){
  
  smples <- 
    slots_chosen_collision |> 
    mutate(id = 1)
  
  for (i in 2:r) {
    tmp <- count_common_slots(n_colleagues = n_colleagues, o = o, p = p)
    tmp$id <- i
    
    smples <-
      smples |> 
      bind_rows(tmp)
    
    #print(paste0(i,"/",r))
  }
  
  return(smples)
}
```






Check:

```{r}
smples <- estimate_common_slots(slots_chosen_collision = slots_chosen_collision,
                                n_colleagues = n_colleagues,
                                o = o,
                                p = p)

glimpse(smples)
```



## Samples summarized

```{r fun-summ-samples}
summarize_samples <- function(smples){
  
   smples_tbl <-
   smples |> 
   #drop_na() |> 
   group_by(Freq) |> 
   summarise(n_matches = n()) |> 
   mutate(prop_matches = n_matches / sum(n_matches)) |> 
   mutate(Freq = replace_na(Freq, 0))
   
   return(smples_tbl)
  
}
```

Check:

```{r}
smples_tbl <- summarize_samples(smples)
smples_tbl
```


## Proportion of matches



```{r fun-prop-match}
prop_match <- function(smples, n_colleagues){
  
 smples_tbl <- summarize_samples(smples)
  
  out_tbl <- smples_tbl |> 
    group_by(we_found_slot = factor(Freq >= n_colleagues, levels = c(FALSE, TRUE)), .drop = FALSE) |> 
    summarise(n_matches = sum(n_matches)) |> 
    mutate(prop_matches = n_matches/sum(n_matches)) 
  
  out <- out_tbl$prop_matches[out_tbl$we_found_slot == TRUE]
  
  stopifnot(class(out) == "numeric")
  
  return(out)
}
```


```{r}
#undebug(prop_match)
prop_match(smples, n_colleagues = 3)
prop_match(smples, n_colleagues = 4)
prop_match(smples, n_colleagues = 5)
```




## Plot results

```{r}
plot_matches <- function(smples_tbl, n_colleagues, p, o){

  smples_tbl |> 
    group_by(we_found_slot = 
               factor(Freq >= n_colleagues, levels = c(FALSE, TRUE)), 
             .drop = FALSE) |> 
    summarise(n_matches = sum(n_matches),
              prop_matches = sum(prop_matches)) |> 
    ggplot() +
  aes(x = we_found_slot, y = prop_matches) +
    geom_col() +
    labs(title = "Proportion of collisions",
         subtitle = paste0(n_colleagues, " colleagues, ", p, " picked time slots, ", o, " options to chose from, ", r, " simulated samples"),
         caption = "The vertical line indicates the event that enough colleagues chose the same time slot.") +
    geom_label(aes(label = round(prop_matches, 2), x = we_found_slot)) 
}
```


```{r}
plot_matches(smples_tbl, n_colleagues, p, o)
```





## All in once function

Here's the do-it-all-in-once function:

```{r fun-matching-prob}
matching_prob <- function(n_colleagues,
                          o,
                          p,
                          r = 1e3,
                          return_prob = TRUE
                          ) {
  first_common_slot <- count_common_slots(n_colleagues, o = o, p = p)
  all_common_slots <- estimate_common_slots(first_common_slot,
                                            n_colleagues = n_colleagues,
                                            o = o,
                                            p = p)
  out <- all_common_slots
  
  if (return_prob) {
    out <- prop_match(all_common_slots, n_colleagues = n_colleagues)
    stopifnot(class(out) == "numeric")
  }
  
  return(out)
}
```


Check it:

```{r}
#undebug(matching_prob)
matching_prob(n_colleagues = 5,
              o = 10,
              p = 3)
```









As can be seen, the probability of finding a matching time slot is quite small, given the parameter values above.
Not impossible, but too low to rely on this approach in my opinion.


# o=10; Make a matching more probable

Let's provide less options too chose from in order to find a time slot for the meeting to your colleagues:



```{r}
n_colleagues <- 3
o <- 7

matching_prob(n_colleagues = n_colleagues,
              o = o,
              p = 3)
```


Looks much better; we have some chances of finding a match.


```{r fig.width=9}
smples2 <- matching_prob(n_colleagues = n_colleagues,
              o = o,
              p = p,
              return_prob = FALSE)

smples_tbl2 <- summarize_samples(smples2)
plot_matches(smples_tbl2, n_colleagues, p = p, o = o)
```


Now we can see that a matching has become more probable, although still not highly likely.






# o=5; Make a matching highly probable

Let's provide only a few options too chose from in order to find a time slot for the meeting to your colleagues:

```{r}
o <- 5  # number of time slot options too chose from
```






```{r fig.width=9}
smples3 <- matching_prob(n_colleagues = n_colleagues,
              o = o,
              p = p,
              return_prob = FALSE)

smples_tbl3 <- summarize_samples(smples3)
plot_matches(smples_tbl3,  n_colleagues, p = p, o = o)
```



That really looks good; that's a realistic chance to find a match.

# Grid of different parameter values


Let's try different parameter values and compute the probability of a match.

Here's the grid using a cartesian expansion:

```{r}
d <- expand_grid(n_colleagues = 2:5,
                 o = c(5, 10, 15, 20, 25, 30),
                 p = c(3, 5, 7, 10))
```




# Populate grid


```{r populate-grid}
d_grid <-
  d |> 
  mutate(match_prob = 
           pmap_dbl(
             .l = list(n_colleagues, o, p), 
             .f = matching_prob,
             .progress = TRUE))
```


# Visualize grid


```{r vis-grid, fig.asp = 1.5, out.width="100%"}
d_grid |> 
  rename(n = n_colleagues) |> 
  ggplot(aes(x = o, y = match_prob)) +
  geom_line() +
  geom_point() +
  facet_grid(n ~ p,
             labeller = labeller(n = label_both, p = label_both)) +
  labs(title = "Proportiong of a match when Doodling for an joint meeting",
       caption = "p: Number of options picked per colleague;\n
       n: number of colleagues approached"
       )
```


Let's try a different visualization:

```{r vis-grid2, fig.asp = 1.5}
d_grid_long <-
  d_grid |> 
  pivot_longer(cols = c(n_colleagues, p))

d_grid |> 
  rename(n = n_colleagues) |> 
  mutate(n = factor(n)) |> 
  ggplot(aes(x = o, y = match_prob, color = n, group = n)) +
  geom_line() +
  geom_point() +
  facet_wrap(~  p , labeller = labeller(p = label_both), ncol = 2) +
  labs(title = "Proportiong of a match when Doodling for an joint meeting",
       caption = "p: Number of options picked per colleague;\n
       n: number of colleagues approached",
       color = "number of\ncolleagues") +
  theme_light() +
  theme(legend.position = "bottom")
```


# Caveats

This analysis builds on some assumptions. One is that the the colleagues choose their slots randomly. 
However, assumption may fail.
For example, if 3 have 5 options and ask to choose 3, people may feel pushed too hard and do crazy things.



# Conclusion

There are a number of things to be learnt from this simulation:

1. The higher the number of _o_ptions to pick from, the less likely is it to come to a match.
2. The highher the number of _p_icked appointment options, the more likely it is to come to a match.
3. The more colleagues are in the game, the less likely it is to come to a match.

All these insights are straight forward. However, we can also make some quantitative conclusions:

- More than 20 options to choose from is crazy no matter what.
- If each colleagues picks 3 options only (what I would do), than you need to present less than 10 options. 
- If you can present 5 options only, you will be on the safe side and will likely come to a match.



# Reproducibility

```{r reproducibility, echo = FALSE}
## Reproducibility info
options(width = 120)
devtools::session_info()

```


